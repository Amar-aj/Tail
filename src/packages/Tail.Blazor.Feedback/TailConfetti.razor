@inherits Tail.Blazor.Core.TailComponentBase
@namespace Tail.Blazor.Feedback
@implements IAsyncDisposable

<div class="@GetContainerClasses()" style="@GetContainerStyle()">
    @if (ShowConfetti)
    {
        <canvas id="@canvasId" class="@GetCanvasClasses()" style="@GetCanvasStyle()"></canvas>
    }
</div>

@code {
    [Parameter] public bool Active { get; set; }
    [Parameter] public EventCallback<bool> ActiveChanged { get; set; }
    [Parameter] public int ParticleCount { get; set; } = 50;
    [Parameter] public double Duration { get; set; } = 3000; // milliseconds
    [Parameter] public List<string> Colors { get; set; } = new();
    [Parameter] public ConfettiShape Shape { get; set; } = ConfettiShape.Mixed;

    private bool ShowConfetti { get; set; }
    private string canvasId = Guid.NewGuid().ToString();
    private IJSObjectReference? jsModule;
    private DotNetObjectReference<TailConfetti>? objRef;

    [Inject] private IJSRuntime JSRuntime { get; set; } = null!;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Load JS module for confetti animation
                // For now, we'll use a simple CSS-based approach
                objRef = DotNetObjectReference.Create(this);
            }
            catch { }
        }

        if (Active && !ShowConfetti)
        {
            ShowConfetti = true;
            await StartConfetti();
        }
        else if (!Active && ShowConfetti)
        {
            ShowConfetti = false;
        }
    }

    protected override void OnParametersSet()
    {
        if (Colors.Count == 0)
        {
            Colors = new List<string>
            {
                "var(--color-primary)",
                "var(--color-success)",
                "var(--color-warning)",
                "var(--color-danger)",
                "var(--color-info)",
                "var(--color-secondary)",
                "var(--color-accent)"
            };
        }
    }

    private async Task StartConfetti()
    {
        // Trigger confetti animation
        await InvokeAsync(StateHasChanged);
        
        // Auto-stop after duration
        _ = Task.Delay((int)Duration).ContinueWith(_ => InvokeAsync(async () =>
        {
            Active = false;
            if (ActiveChanged.HasDelegate)
            {
                await ActiveChanged.InvokeAsync(false);
            }
            ShowConfetti = false;
            await InvokeAsync(StateHasChanged);
        }));
    }

    public async ValueTask DisposeAsync()
    {
        objRef?.Dispose();
        if (jsModule != null)
        {
            await jsModule.DisposeAsync();
        }
    }

    // Styling methods using global CSS variables
    private string GetContainerClasses()
    {
        var classes = new List<string> { "fixed inset-0 pointer-events-none z-50" };
        if (!string.IsNullOrEmpty(CssClass))
        {
            classes.Add(CssClass);
        }
        return string.Join(" ", classes);
    }

    private string GetContainerStyle()
    {
        return "overflow: hidden;";
    }

    private string GetCanvasClasses()
    {
        return "w-full h-full";
    }

    private string GetCanvasStyle()
    {
        return string.Empty;
    }
}



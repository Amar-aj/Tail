@inherits Tail.Blazor.Core.TailComponentBase
@namespace Tail.Blazor.Core.Theme
@using Microsoft.JSInterop
@inject ThemeEngine Theme
@inject IJSRuntime JS
@implements IAsyncDisposable

<button 
    type="button"
    class="@GetButtonClasses()"
    @onclick="ToggleTheme"
    title="@GetTooltipText()"
    aria-label="Toggle theme"
    @attributes="AdditionalAttributes">
    
    @if (ShowLabel)
    {
        <span class="flex items-center space-x-2">
            @GetIcon()
            <span>@GetLabelText()</span>
        </span>
    }
    else
    {
        @GetIcon()
    }
</button>

@code {
    [Parameter] public bool ShowLabel { get; set; } = false;
    [Parameter] public ThemeToggleStyle Style { get; set; } = ThemeToggleStyle.Icon;
    [Parameter] public EventCallback<ThemeMode> OnThemeChanged { get; set; }
    [Parameter] public string? LightModeLabel { get; set; } = "Light";
    [Parameter] public string? DarkModeLabel { get; set; } = "Dark";
    
    private IJSObjectReference? _jsModule;
    private const string StorageKey = "tail-blazor-theme";
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadThemeFromStorage();
        }
    }
    
    private async Task LoadThemeFromStorage()
    {
        try
        {
            // Import the JS module - Blazor will handle the correct path
            _jsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./_content/Tail.Blazor.Core/theme-toggle.js");
            
            var savedTheme = await _jsModule.InvokeAsync<string?>("getTheme", StorageKey);
            
            if (!string.IsNullOrEmpty(savedTheme) && Enum.TryParse<ThemeMode>(savedTheme, out var mode))
            {
                Theme.Mode = mode;
                await ApplyThemeToDocument();
                StateHasChanged();
            }
            else
            {
                // Check system preference
                var prefersDark = await _jsModule.InvokeAsync<bool>("prefersDarkMode");
                Theme.Mode = prefersDark ? ThemeMode.Dark : ThemeMode.Light;
                await SaveThemeToStorage();
                await ApplyThemeToDocument();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading theme: {ex.Message}");
            // Fallback - apply theme without JS module
            await ApplyThemeDirectly();
        }
    }
    
    private async Task ApplyThemeDirectly()
    {
        try
        {
            // Direct DOM manipulation fallback
            var isDark = Theme.Mode == ThemeMode.Dark;
            var script = isDark 
                ? "document.documentElement.classList.add('dark')" 
                : "document.documentElement.classList.remove('dark')";
            await JS.InvokeVoidAsync("eval", script);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in fallback theme apply: {ex.Message}");
        }
    }
    
    private async Task ToggleTheme()
    {
        Theme.Mode = Theme.Mode == ThemeMode.Light ? ThemeMode.Dark : ThemeMode.Light;
        await SaveThemeToStorage();
        await ApplyThemeToDocument();
        
        if (OnThemeChanged.HasDelegate)
        {
            await OnThemeChanged.InvokeAsync(Theme.Mode);
        }
    }
    
    private async Task SaveThemeToStorage()
    {
        try
        {
            if (_jsModule != null)
            {
                await _jsModule.InvokeVoidAsync("saveTheme", StorageKey, Theme.Mode.ToString());
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving theme: {ex.Message}");
        }
    }
    
    private async Task ApplyThemeToDocument()
    {
        try
        {
            if (_jsModule != null)
            {
                var isDark = Theme.Mode == ThemeMode.Dark;
                await _jsModule.InvokeVoidAsync("applyTheme", isDark);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error applying theme: {ex.Message}");
        }
    }
    
    private string GetButtonClasses()
    {
        var classes = new List<string>
        {
            "inline-flex items-center justify-center",
            "transition-colors duration-200",
            "focus:outline-none focus:ring-2 focus:ring-offset-2"
        };
        
        switch (Style)
        {
            case ThemeToggleStyle.Icon:
                classes.Add("p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800");
                classes.Add("text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100");
                classes.Add("focus:ring-blue-500");
                break;
                
            case ThemeToggleStyle.Button:
                classes.Add("px-4 py-2 rounded-lg font-medium");
                classes.Add("bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700");
                classes.Add("text-gray-900 dark:text-gray-100");
                classes.Add("focus:ring-blue-500");
                break;
                
            case ThemeToggleStyle.Outlined:
                classes.Add("px-4 py-2 rounded-lg font-medium border-2");
                classes.Add("border-gray-300 dark:border-gray-600");
                classes.Add("hover:border-gray-400 dark:hover:border-gray-500");
                classes.Add("text-gray-900 dark:text-gray-100");
                classes.Add("focus:ring-blue-500");
                break;
        }
        
        if (!string.IsNullOrEmpty(CssClass))
        {
            classes.Add(CssClass);
        }
        
        return string.Join(" ", classes);
    }
    
    private RenderFragment GetIcon()
    {
        return __builder =>
        {
            if (Theme.Mode == ThemeMode.Light)
            {
                // Sun icon
                <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                          d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            }
            else
            {
                // Moon icon
                <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                          d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                </svg>
            }
        };
    }
    
    private string GetLabelText()
    {
        return Theme.Mode == ThemeMode.Light 
            ? (LightModeLabel ?? "Light") 
            : (DarkModeLabel ?? "Dark");
    }
    
    private string GetTooltipText()
    {
        return Theme.Mode == ThemeMode.Light 
            ? "Switch to dark mode" 
            : "Switch to light mode";
    }
    
    public async ValueTask DisposeAsync()
    {
        if (_jsModule != null)
        {
            await _jsModule.DisposeAsync();
        }
    }
}
